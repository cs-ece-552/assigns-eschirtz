$date
	Mon Mar 04 23:24:43 2019
$end
$version
	ModelSim Version 10.4a
$end
$timescale
	1ns
$end

$scope module control_hier_bench $end
$var wire 1 ! err $end
$var wire 1 " RegWrite $end
$var wire 1 # DMemWrite $end
$var wire 1 $ DMemEn $end
$var wire 1 % ALUSrc2 $end
$var wire 1 & PCSrc $end
$var wire 1 ' PCImm $end
$var wire 1 ( MemToReg $end
$var wire 1 ) DMemDump $end
$var wire 1 * Jump $end
$var wire 1 + RegDst [1] $end
$var wire 1 , RegDst [0] $end
$var wire 1 - SESel [2] $end
$var wire 1 . SESel [1] $end
$var wire 1 / SESel [0] $end
$var reg 5 0 OpCode [4:0] $end
$var reg 2 1 Funct [1:0] $end
$var integer 32 2 cycle_count $end
$var wire 1 3 clk $end
$var wire 1 4 rst $end
$var reg 1 5 fail $end
$var reg 6 6 count [5:0] $end

$scope module DUT $end
$var wire 1 7 OpCode [4] $end
$var wire 1 8 OpCode [3] $end
$var wire 1 9 OpCode [2] $end
$var wire 1 : OpCode [1] $end
$var wire 1 ; OpCode [0] $end
$var wire 1 < Funct [1] $end
$var wire 1 = Funct [0] $end
$var wire 1 ! err $end
$var wire 1 " RegWrite $end
$var wire 1 # DMemWrite $end
$var wire 1 $ DMemEn $end
$var wire 1 % ALUSrc2 $end
$var wire 1 & PCSrc $end
$var wire 1 ' PCImm $end
$var wire 1 ( MemToReg $end
$var wire 1 ) DMemDump $end
$var wire 1 * Jump $end
$var wire 1 + RegDst [1] $end
$var wire 1 , RegDst [0] $end
$var wire 1 - SESel [2] $end
$var wire 1 . SESel [1] $end
$var wire 1 / SESel [0] $end
$var wire 1 > clk $end
$var wire 1 ? rst $end
$var wire 1 @ errClkRst $end

$scope module clk_generator $end
$var reg 1 A clk $end
$var reg 1 B rst $end
$var wire 1 @ err $end
$var integer 32 C cycle_count $end
$upscope $end

$scope module c0 $end
$var wire 1 7 OpCode [4] $end
$var wire 1 8 OpCode [3] $end
$var wire 1 9 OpCode [2] $end
$var wire 1 : OpCode [1] $end
$var wire 1 ; OpCode [0] $end
$var wire 1 < Funct [1] $end
$var wire 1 = Funct [0] $end
$var wire 1 ! err $end
$var wire 1 " RegWrite $end
$var wire 1 # DMemWrite $end
$var wire 1 $ DMemEn $end
$var wire 1 % ALUSrc2 $end
$var wire 1 & PCSrc $end
$var wire 1 ' PCImm $end
$var wire 1 ( MemToReg $end
$var wire 1 ) DMemDump $end
$var wire 1 * Jump $end
$var wire 1 + RegDst [1] $end
$var wire 1 , RegDst [0] $end
$var wire 1 - SESel [2] $end
$var wire 1 . SESel [1] $end
$var wire 1 / SESel [0] $end
$var wire 1 D is7_5 $end
$var wire 1 E is10_8 $end
$var wire 1 F is_R7 $end
$var wire 1 G zext5bit $end
$var wire 1 H zext8bit $end
$var wire 1 I ext5bit $end
$var wire 1 J ext8bit $end
$var wire 1 K zext11bit $end
$var wire 1 L is10010 $end
$var wire 1 M alu_op $end
$var wire 1 N is_10010 $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b1 0
bx 1
x5
b1 6
1A
1B
bx 2
b1 C
0!
0"
0#
0$
0%
0&
0'
0(
0)
0*
x,
x+
x/
x.
x-
13
14
1>
1?
z@
0D
0E
0F
0G
0H
0I
0J
0K
zL
zM
0N
x=
x<
1;
0:
09
08
07
$end
#50
0A
0>
03
#100
1A
1>
13
b10 0
b10 6
b10 C
0;
1:
#150
0A
0>
03
#200
1A
1>
13
b11 0
b11 6
b11 C
1;
#201
0B
04
0?
#250
0A
0>
03
#300
1A
1>
13
b100 0
b100 6
b100 C
0;
0:
19
1K
1'
1&
1.
1-
#350
0A
0>
03
#400
1A
1>
13
b101 0
b101 6
b101 C
1;
0K
1J
0'
1*
0.
#450
0A
0>
03
#500
1A
1>
13
b110 0
b110 6
b110 C
0;
1:
1K
0J
1"
1'
0*
1F
1,
1+
1.
#550
0A
0>
03
#600
1A
1>
13
b111 0
b111 6
b111 C
1;
0K
1J
0'
1*
0.
#650
0A
0>
03
#700
1A
1>
13
b1000 0
b1000 6
b1000 C
0;
0:
09
18
0J
0*
1I
0F
1D
0&
0+
1.
0-
#750
0A
0>
03
#800
1A
1>
13
b1001 0
b1001 6
b1001 C
1;
#850
0A
0>
03
#900
1A
1>
13
b1010 0
b1010 6
b1010 C
0;
1:
0I
1G
0/
0.
#950
0A
0>
03
#1000
1A
1>
13
b1011 0
b1011 6
b1011 C
1;
#1050
0A
0>
03
#1100
1A
1>
13
b1100 0
b1100 6
b1100 C
0;
0:
19
1J
0"
0G
0D
1&
x,
x+
x/
1-
#1150
0A
0>
03
#1200
1A
1>
13
b1101 0
b1101 6
b1101 C
1;
#1250
0A
0>
03
#1300
1A
1>
13
b1110 0
b1110 6
b1110 C
0;
1:
#1350
0A
0>
03
#1400
1A
1>
13
b1111 0
b1111 6
b1111 C
1;
#1450
0A
0>
03
#1500
1A
1>
13
b10000 0
b10000 6
b10000 C
0;
0:
09
08
17
0J
1#
1I
0&
1.
0-
1$
#1550
0A
0>
03
#1600
1A
1>
13
b10001 0
b10001 6
b10001 C
1;
1"
1(
0#
#1650
0A
0>
03
#1700
1A
1>
13
b10010 0
b10010 6
b10010 C
0;
1:
1E
0(
1N
0,
1+
0$
1H
0I
1/
0.
#1750
0A
0>
03
#1800
1A
1>
13
b10011 0
b10011 6
b10011 C
1;
1#
0N
1$
0H
1I
x/
1.
#1850
0A
0>
03
#1900
1A
1>
13
b10100 0
b10100 6
